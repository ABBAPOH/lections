Еще одна категоризация языков программирования - по тому, является язык компилируеым или
интерпретируемым. В общем случае, язык может быть и таким и таким, но на практике язык создается с
определенной целью и инфраструктурой под неё и как правило выбирается один из двух путей. Хотя есть
копилятор питона и интерпретатор Си, ими пользуются не так часто, как хотелось бы разработчикам
(хотя компилятор питона я использовал)

Разберем вкратце интерпретируемые языки. Есть специальная программа-интерпретатор, как правило,
написанная на языке низкого уровня (скажем, на си). Эта программа принимает на вход файл с кодом и
построчно его интерпретирует, то есть разбирает синтаксис/семантику и сразу исполняет. В процессе
она строит какие-то структуры, напирмер, заводит переменные или запоминает, какие типы/функции были
объявлены, чтобы можно было выдать ошику при использовании необъявленных идентификаторов или
выполнять код функции. Из плюсов интерпретируемых языков можно назвать кроссплатформенность -
программа, написанная один раз будет работать на всех платформах, на которых есть интерпретатор.
Рефлексия - это возможность программы менять свое состояние. Например, в питоне можно в рантайме
добавлять функции в объект или заменить одну функцию на другую. Интроспекция - это возможность
получать в runtime информацию о типах (например, получить имена всех функций/переменных класса/
объекта). Из минусов стоит отметить что такие языки потребляют больше ресурсов и более медленные,
чем компилируемые. Это происходит из-за наличия прослойки в виде интерпретатора. Также существенным
минусом является то, что ошибки отлавливаются только во время выполнения - программа может корректно
выполнить половину действий (напирмер, создать кучу файлов) а потом упасть из-за несоответствия
типов - в этом случае завершающий код, скажем, удаляющий файлы, не будет вызван.

Другой тип языков, компилируемый, отличается тем, что исполняется непосредственно ОС.
Программа0-компилятор берет текст программы на исходном языке и преобразует его в файл, содежращий
непосредственно инструкции для выполнения на процессоре. За счет отсутствия прослойки в виде
интерпретатора, программы выполняются быстрее (в десятки, а то и сотни раз). Но, так как в файле
хранятся непосредственно команды процессору, этот файл может исполняться только на машинах с такой
же архитектурой, то есть не является переносимым. Кроме того, формат файла различается в разных
операционных системах. Пример с helloworld.

Рассмотрим процесс компиляции. Сперва, отрабатывает препроцессор, запустить его отдельно можно с
ключом -E. Он вставляет тексты других файлов через #include, разворачивает #define и обрабатывает
прочие директивы препроцессора (#ifdef). Затем отрабатывает транслятор - проверяет синтаксическую
(что скобочки расставлены верно, что идентификаторы правильные) и семантическую корректность (что
идентификаторы объявлены, что функции вызываются с верными аргументами и тп), выполняет оптимизации,
генерирует ассемблер. Пример с ассеблерованием. Затем, компилятор ассемблера (например, as)
генерирует машинные команды и записывает их в объектный файл вместе с символами импорта и экспорта
(функциями или внешними переменными). Пример с генерацией *.o файла. На последнем этапе линковщик
собирает объектные файлы в исполняемый файл.

В юниксах, помимо непосредственно бинарных исполняемых файлов, могут быть скриптовые файлы. Вообще,
любой файл может быть исполняемым, исполняемость - это специальный флажок в правах файла. То, как
файл исполняется, определяется по содержимому - в случае бинарника, это его заголовок, в случае
скрипта - специальная последовательность символов #!, за которой следует путь к интерпретатору
файла. Как уже упоминалось, бинарники в разных ОС разные - в венде - PE (portable executable), в
линуксе - elf (executable and linkable format), Mach-o в маке.

Так как, чтобы собрать программу, нужно выполнить достаточно много действий, появились средства
автоматизации, называемыми системами сборки. Одной из самых старых систем сборки (и использующейся
до сих пор), является make. Программа make получает на вход Makefile (или ищет его в текущем
каталоге). Makefile содержит набор целей, которые также можно указать при вызове make. Если цель
не указана, то собирается первая цель. Каждая цель может зависеть от других целей или от файлов -
если файл обновился со времени борки цели, то цель пересобирается. Также цель содержит набор команд,
которые выполняются при сборке цели. Также, можно задавать переменные, чтобы не дублировать код.
Для тепичных действий, типа превращения сорсов в объектники есть страшная магия в виде
синтаксического сахара.

В Юникс многие программы традиционно использовали следующю схему. Есть скрипт configure, написанный
на баше, который проверяет наличие в системе библиотек, компиляторов и тп и генерит мейкфайл для
сборки. Например, Qt до сих пор так собирается. Затем, программа собирается мейкфалом. После того,
как она собрана, можно установить её в систему с помощью цели install, которая копирует файлы
программы куда надо. Тем не менее, эта схема неудобна тем, что необходимо руками писать скрипт
конфигурации, если нужно поддерживать много платформ, это становится головной болью.

Одной из попыток уменьшить эту боль являются autotools. Но там дичь, там для configure скрипта есть
шаблон, для мейкфайла есть шаблон, и всё это ещё и не работает.

В различных ОС есть "свои" системы сборки (так как мейкфайл - неудобно, да и ИДЕ их не умеет читать)
например - VCBuild для Студии или XCodeBuild для маковской ИДЕ Xcode. Они весьма неплохи по скорости,
по крайней мере VCBuild, но не являются переносимыми.

Попыткой сделать переносимые проекты являются QMake, CMake и QBS. QMake - это система сборки,
используемая в Qt. У неё очень много минусов и её тоже давно пора закопать.

CMake (Crossplatform Make) - это некое описание проекта, из которого генерятся файлы для backend'ов
- например, всё того же make, VCBuild или XCode. Плюс такого подхода в том, что, с одной стороны,
имеется платформонезависимое описание проекта, с другой - поддержка различных иде и способов
консольной сборки (кто чем привык, тот и собирает). Минусом является то, что CMake огребает от
минусов backend'ов (как правило, скорость сборки). Кроме того, синтаксис CMake очень сложен, постоянно
приходится лазить в документацию. Из плюсов - CMake работает быстро (например, по сравнению с QMake)
красво раскрашивает вывод в консоли, много функционала из коробки, например, по поиску пакетов.

QBS - это относительно новая система сборки всё тех же кутешников. Её главное отличие от CMake в
том, что она не является генератором, а сама вызывает компилятор и необходиые тулзы. Кроме того,
это всё та же декларативка.

Небольшой оффтоп. Во всех операцонках есть так называемые переменные окружения. Это набор строк
ключ-значение, который есть у каждого процесса. При запуске одним процессом другого, новый процесс
наследует переменные родительского; но может их менять. Например, чтобы посмотреть переменные
консоли, стоит вызвать команду env. Чтобы посмотреть значение одной переменной, можно
воспользоваться командой echo. Чтобы поменять переменную в баше, есть команда export. Также, можно
задать переменную при запуске нового процесса. Пример про getenv.

Помимо, собственно, биарников приложений, есть библиотеки. Библиотеки - это сущность, содержащая в
себе функции, которые может вызывать приложение. Библиотеки бывают двух типов - статические и
разделяемые. Статические библиотеки на этапе компиляции встраиваются в программу. По сути, такая
библиотека - это архив с объектными файлами, которые её составляют. Даже название программы, которая
создаёт статические библиотеки, говорящее - ar. Разделяемые библиотеки, напротив, загружаются при
запуске программы, а при компиляции в программу вставляется ссылка на библиотеку. На самом деле,
есть ещё один способ загрузки библиотек - вручную при помощи функций dlopen/LoadLibrary. В этом
случае, при компиляции не сохраняется никакой инфы о библиотеке и приложение само ищет и загружает
их. Это нужно для т.н. плагинов - то есть расширений приложения. Например, весь Qt Creator состоит
из кучи плагинов.
Как при загрузке приложения осуществляется поиск библиотек? В каждой системе по-разному. В венде
библиотеки ищутся по имение либо в папке с бинарником, либо в системных путях. В линуксе - либо в путях,
заданных переменной LD_LIBRARY_PATH, либо с помощью @rpath. @rpath - это список относительных
(относильно бинарника) путей для поиска, например ../lib. В маке похожий способ, но там, вшивается
не имя библиотеки, а путь к ней. Если путь относительный, то библиотека ищется в системных. Также,
есть rpath. Ну и LD_LIBRARY_PATH тут зовётся DYLD_LIBRARY_PATH.
